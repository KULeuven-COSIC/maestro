use std::{fmt::{Debug, Formatter}, ops::{Add, AddAssign, Mul, Neg, Sub}};

use rand::{CryptoRng, Rng};
use sha2::Digest;

use super::{Field, FieldDigestExt, FieldRngExt};

/// An element of GF(2^4) := GF(2)[X] / X^4+x+1 
/// 
/// An element is represented as a byte where the top 4 bits are always 0.
#[derive(Copy, Clone, Default, PartialEq)]
pub struct GF4(u8);

const SQ_TABLE: [u8; 16] = [0x00, 0x01, 0x04, 0x05, 0x03, 0x02, 0x07, 0x06, 0x0c, 0x0d, 0x08, 0x09, 0x0f, 0x0e, 0x0b, 0x0a];
const MUL_TABLE: [[u8; 16];16] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f],
    [0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f, 0x0d],
    [0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02],
    [0x00, 0x04, 0x08, 0x0c, 0x03, 0x07, 0x0b, 0x0f, 0x06, 0x02, 0x0e, 0x0a, 0x05, 0x01, 0x0d, 0x09],
    [0x00, 0x05, 0x0a, 0x0f, 0x07, 0x02, 0x0d, 0x08, 0x0e, 0x0b, 0x04, 0x01, 0x09, 0x0c, 0x03, 0x06],
    [0x00, 0x06, 0x0c, 0x0a, 0x0b, 0x0d, 0x07, 0x01, 0x05, 0x03, 0x09, 0x0f, 0x0e, 0x08, 0x02, 0x04],
    [0x00, 0x07, 0x0e, 0x09, 0x0f, 0x08, 0x01, 0x06, 0x0d, 0x0a, 0x03, 0x04, 0x02, 0x05, 0x0c, 0x0b],
    [0x00, 0x08, 0x03, 0x0b, 0x06, 0x0e, 0x05, 0x0d, 0x0c, 0x04, 0x0f, 0x07, 0x0a, 0x02, 0x09, 0x01],
    [0x00, 0x09, 0x01, 0x08, 0x02, 0x0b, 0x03, 0x0a, 0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e],
    [0x00, 0x0a, 0x07, 0x0d, 0x0e, 0x04, 0x09, 0x03, 0x0f, 0x05, 0x08, 0x02, 0x01, 0x0b, 0x06, 0x0c],
    [0x00, 0x0b, 0x05, 0x0e, 0x0a, 0x01, 0x0f, 0x04, 0x07, 0x0c, 0x02, 0x09, 0x0d, 0x06, 0x08, 0x03],
    [0x00, 0x0c, 0x0b, 0x07, 0x05, 0x09, 0x0e, 0x02, 0x0a, 0x06, 0x01, 0x0d, 0x0f, 0x03, 0x04, 0x08],
    [0x00, 0x0d, 0x09, 0x04, 0x01, 0x0c, 0x08, 0x05, 0x02, 0x0f, 0x0b, 0x06, 0x03, 0x0e, 0x0a, 0x07],
    [0x00, 0x0e, 0x0f, 0x01, 0x0d, 0x03, 0x02, 0x0c, 0x09, 0x07, 0x06, 0x08, 0x04, 0x0a, 0x0b, 0x05],
    [0x00, 0x0f, 0x0d, 0x02, 0x09, 0x06, 0x04, 0x0b, 0x01, 0x0e, 0x0c, 0x03, 0x08, 0x07, 0x05, 0x0a],
    ];

impl GF4 {
    // Generates a new element of `GF(2^4)`. The top 4 bits are ignored.
    pub fn new(x:u8) -> Self{
        GF4(x & 0x0F)
    }

    pub fn cube(self) -> Self {
        Self(SQ_TABLE[self.0 as usize])
    }

    /// Pack to elements of GF4 into a single byte
    pub fn pack(ah:GF4,al:GF4) -> u8 {
        (ah.0 << 4) + al.0
    }

    pub fn unpack(b:u8) -> (GF4,GF4) {
        //here we abuse the fact that new ignores the high bits.
        (GF4::new(b>>4),GF4::new(b))
    }
} 

impl Field for GF4 {
    fn size() -> usize {
        1
    }

    fn zero() -> Self {
        Self(0u8)
    }

    fn is_zero(&self) -> bool {
        self.0 == 0
    }

    fn as_byte_vec<'a, I: IntoIterator<Item=&'a Self>>(it: I) -> Vec<u8> where Self: 'a {
        it.into_iter().map(|gf| gf.0).collect()
    }

    fn from_byte_vec(v: Vec<u8>) -> Vec<Self> {
        v.into_iter().map(|byte| GF4::new(byte)).collect()
    }

    fn from_byte_slice(v: Vec<u8>, dest: &mut [Self]) {
        v.into_iter().zip(dest).for_each(|(byte, dst)| *dst = GF4::new(byte))
    }
}

impl Add for GF4 {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 ^ rhs.0)
    }
    
}

impl AddAssign for GF4 {
    fn add_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}

impl Sub for GF4 {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 ^ rhs.0)
    }
}

/// Additive Inverse
impl Neg for GF4 {
    type Output = GF4;

    fn neg(self) -> Self::Output {
        self
    }
}

impl Mul for GF4 {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self(MUL_TABLE[self.0 as usize][rhs.0 as usize])
    }
}

impl Debug for GF4 {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "GF4(0x{:01x})", self.0 & 0x0F)
    }
}

impl<R: Rng + CryptoRng> FieldRngExt<GF4> for R {
    fn generate(&mut self, n: usize) -> Vec<GF4> {
        let mut r = vec![0; n];
        self.fill_bytes(&mut r);
        r.into_iter().map(|x| GF4::new(x)).collect()
    }

    fn fill(&mut self, buf: &mut [GF4]) {
        let mut v = vec![0u8; buf.len()];
        self.fill_bytes(&mut v);
        buf.iter_mut().zip(v).for_each(|(x, r)| x.0 = r & 0x0F)
    }
}

impl<D: Digest> FieldDigestExt<GF4> for D {
    fn update(&mut self, message: &[GF4]) {
        for x in message {
            self.update(&[x.0]);
        }
    }
}


#[cfg(test)]
mod test {
    use super::GF4;


    #[test]
    fn test_debug_format(){
        let x = GF4(0x0a);
        assert_eq!(format!("{:?}",x),"GF4(0xa)", "Format should match")
    }

    #[test]
    fn test_packing(){
        let x = GF4(0x0f);
        let y = GF4(0x01);
        let b = GF4::pack(x,y);
        assert_eq!((x,y),GF4::unpack(b), "Packing and unpacking should work")
    }


}