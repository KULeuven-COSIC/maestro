use std::ops::{Add, AddAssign, Sub, Neg, Mul};
use itertools::Itertools;
// use bytemuck::TransparentWrapper;
use ghash::{GHash, universal_hash::{KeyInit, UniversalHash}};
use rand::{Rng, CryptoRng};
use sha2::Digest;

use crate::share::{field::GF8, Field, FieldDigestExt, FieldRngExt};


#[derive(Copy, Clone, Debug, PartialEq, Eq)] //, TransparentWrapper)]
#[repr(transparent)]
pub struct GF128([u8; 16]);

impl GF128 {
    pub fn into_gf8(self) -> Vec<GF8> {
        self.0.into_iter().map(|b| GF8(b)).collect()
    }
}

impl Field for GF128 {
    fn is_zero(&self) -> bool {
        return self.0.iter().all(|x| *x == 0);
    }
    fn size() -> usize {
        16
    }
    fn zero() -> Self {
        GF128([0u8; 16])
    }

    fn as_byte_vec(it: impl IntoIterator<Item= impl std::borrow::Borrow<Self>>) -> Vec<u8> {
        it.into_iter().flat_map(|gf| {
            let arr = gf.borrow().0.clone();
            arr.into_iter()
        }).collect()
    }

    fn from_byte_slice(v: Vec<u8>, dest: &mut [Self]) {
        debug_assert_eq!(dest.len()*16, v.len());
        dest.iter_mut().zip(v.into_iter().chunks(16).into_iter()).for_each(|(dst, chunk)| {
            chunk.into_iter().enumerate().for_each(|(i,byte)| {
                dst.0[i] = byte;
            });
        });
    }

    fn from_byte_vec(v: Vec<u8>) -> Vec<Self> {
        debug_assert!(v.len()%16 == 0);
        v.into_iter().chunks(16).into_iter().map(|chunk| {
            let mut bytes = [0u8; 16];
            bytes.iter_mut().zip(chunk.into_iter()).for_each(|(dst,byte)| *dst = byte);
            Self(bytes)
        }).collect()
    }
}

impl Default for GF128 {
    fn default() -> Self {
        Self::zero()
    }
}

impl Add for GF128 {
    type Output = GF128;
    
    fn add(mut self, rhs: Self) -> Self::Output {
        self += rhs;
        self
    }
}

impl AddAssign for GF128 {
    fn add_assign(&mut self, rhs: Self) {
        for i in 0..16 {
            self.0[i] ^= rhs.0[i];
        }
    }
}

impl Sub for GF128 {
    type Output = GF128;
    fn sub(self, rhs: Self) -> Self::Output {
        self + rhs
    }
}

impl Neg for GF128 {
    type Output = GF128;
    fn neg(self) -> Self::Output {
        self
    }
}

impl Mul for GF128 {
    type Output = GF128;
    fn mul(self, rhs: Self) -> Self::Output {
        // use GHASH to realize GF(2^128) multiplication
        // the first input block in GHASH is computed as Y = X * H
        // so we set self as key and rhs as input
        // and obtain Y from the output of the hash
        let mut hasher = GHash::new(&self.0.into());
        let block: ghash::Block = rhs.0.into();
        hasher.update(&[block]);
        let result = hasher.finalize();
        GF128(result.into())
    }
}

#[derive(Debug)]
pub struct TryFromGF128SliceError(());

impl TryFrom<&[GF8]> for GF128 {
    type Error = TryFromGF128SliceError;
    fn try_from(value: &[GF8]) -> Result<Self, Self::Error> {
        if value.len() != 16 { return Err(TryFromGF128SliceError(()))}
        let mut bytes = [0u8; 16];
        for i in 0..16 {
            bytes[i] = value[i].0;
        }
        Ok(GF128(bytes))
    }
}

impl TryFrom<&[u8]> for GF128 {
    type Error = TryFromGF128SliceError;
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        if value.len() != 16 { return Err(TryFromGF128SliceError(()))}
        let mut bytes = [0u8; 16];
        bytes.copy_from_slice(value);
        Ok(GF128(bytes))
    }
}

// unsafe impl TransparentWrapper<[u8; 16]> for GF128 {}

impl<R: Rng + CryptoRng> FieldRngExt<GF128> for R {
    fn fill(&mut self, buf: &mut [GF128]) {
        let mut bytes = vec![0u8; 16*buf.len()];
        self.fill_bytes(&mut bytes);
        let mut it = bytes.into_iter();
        for el in buf {
            for i in 0..16 {
                el.0[i] = it.next().unwrap();
            }
        }
    }
    fn generate(&mut self, n: usize) -> Vec<GF128> {
        (0..n).map(|_| {
            let mut bytes = [0u8; 16];
            self.fill_bytes(&mut bytes);
            GF128(bytes)
        }).collect()
    }
}

impl<D: Digest> FieldDigestExt<GF128> for D {
    fn update(&mut self, message: &[GF128]) {
        for m in message {
            self.update(m.0);
        }
    }
}

// impl FieldVectorCommChannel<GF128> for CommChannel {
//     fn read_vector(&mut self, buffer: &mut [GF128]) -> std::io::Result<()> {
//         let mut buf = vec![0u8; 16*buffer.len()];
//         self.read(&mut buf)?;
//         for (dst, chunk) in buffer.iter_mut().zip(buf.into_iter().chunks(16).into_iter()) {
//             for (i,x) in chunk.enumerate() {
//                 dst.0[i] = x;
//             }
//         }
//         Ok(())
//     }

//     fn write_vector(&mut self, vector: &[GF128]) -> std::io::Result<()> {
//         let mut buf = vec![0u8; 16*vector.len()];
//         for (i,xi) in vector.iter().enumerate() {
//             buf[16*i..16*i+16].copy_from_slice(&xi.0);
//         }
//         self.write(&buf)
//     }
// }

#[cfg(test)]
mod test {
    use itertools::Itertools;
    use super::GF128;

    #[test]
    fn gf128_mul() {
        let xs: [GF128; 10] = [
            GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]),
            GF128([0x87, 0xd0, 0x92, 0x6c, 0x5d, 0x31, 0x28, 0xa6, 0xd9, 0x9e, 0x43, 0xfd, 0x3a, 0xab, 0x93, 0xda]),
            GF128([0x39, 0x3a, 0x50, 0x5a, 0x96, 0xdc, 0x27, 0x89, 0x76, 0xe3, 0x55, 0x17, 0xa2, 0x01, 0x2e, 0x2b]),
            GF128([0xd2, 0xc0, 0x17, 0x30, 0x71, 0xbe, 0x56, 0xca, 0x5d, 0x99, 0xc8, 0x98, 0x46, 0xdc, 0xf2, 0x7f]),
            GF128([0x17, 0x44, 0x59, 0xad, 0xa0, 0x00, 0xb6, 0x96, 0xe3, 0x0c, 0x2d, 0x07, 0x0e, 0x5c, 0x32, 0x60]),
            GF128([0x9c, 0x49, 0x90, 0x8e, 0x87, 0x66, 0x59, 0xe4, 0x01, 0xa2, 0xfc, 0x47, 0x7f, 0x70, 0x46, 0x16]),
            GF128([0xb4, 0x1f, 0x43, 0xd4, 0x20, 0xf9, 0x6c, 0x83, 0x06, 0x99, 0x8a, 0x93, 0x75, 0x3c, 0xf3, 0x13]),
            GF128([0x05, 0x04, 0xa1, 0x8c, 0x6b, 0xfa, 0x72, 0x6c, 0x9d, 0xee, 0x33, 0x9c, 0x5f, 0xf8, 0xb2, 0x93]),
            GF128([0x18, 0xf5, 0x69, 0xb7, 0x6f, 0x55, 0x3c, 0x76, 0xee, 0x46, 0x89, 0xe4, 0x83, 0x7e, 0xf7, 0x88]),
            GF128([0x82, 0x19, 0x16, 0x6d, 0x93, 0x08, 0xd9, 0xb1, 0xf6, 0x8c, 0x4e, 0xd6, 0x85, 0x81, 0x6a, 0x1e]),
        ];
        let ys: [GF128; 10] = [
            GF128([0xf6, 0xd3, 0x55, 0x67, 0x29, 0x91, 0x5d, 0x98, 0x58, 0xe6, 0xfc, 0xdb, 0xe4, 0xf4, 0x64, 0x68]),
            GF128([0x8d, 0xf9, 0x55, 0x21, 0x02, 0x30, 0xd2, 0x79, 0x3c, 0xa1, 0xcf, 0x42, 0x23, 0x3a, 0x60, 0x99]),
            GF128([0x8e, 0xb5, 0x80, 0x37, 0xc7, 0xdd, 0x4f, 0x20, 0x45, 0x4c, 0x7b, 0x2a, 0xc0, 0x5f, 0x12, 0x4e]),
            GF128([0x5a, 0x68, 0xef, 0xdb, 0x18, 0xc2, 0xd4, 0x54, 0x64, 0xa4, 0x96, 0x07, 0x5f, 0x76, 0x21, 0x6d]),
            GF128([0xac, 0xa1, 0xa4, 0x74, 0x80, 0x74, 0x14, 0x45, 0x40, 0x0f, 0x6f, 0x81, 0x6e, 0x02, 0xcf, 0xc8]),
            GF128([0x6a, 0x3f, 0x25, 0x82, 0x82, 0xf9, 0x56, 0xe6, 0x1f, 0xed, 0x6e, 0x7e, 0xe3, 0x8f, 0x6b, 0x90]),
            GF128([0x31, 0x10, 0x05, 0x31, 0x04, 0x98, 0x76, 0x45, 0xa7, 0x66, 0xc6, 0x17, 0x68, 0x16, 0x5f, 0x52]),
            GF128([0xd5, 0x04, 0x54, 0x58, 0xfe, 0xaa, 0xbe, 0x9d, 0x18, 0x2d, 0x9b, 0xfc, 0x3c, 0x07, 0x8d, 0xed]),
            GF128([0x96, 0x13, 0x1f, 0x1b, 0xab, 0x16, 0x60, 0xd3, 0xfb, 0xa6, 0x6a, 0xe3, 0x3c, 0xc9, 0x36, 0x12]),
            GF128([0xce, 0x8a, 0x6a, 0x4d, 0xb4, 0xa9, 0x6a, 0xcd, 0xd6, 0x06, 0xca, 0x93, 0x8c, 0xd7, 0x81, 0x23]),
        ];
        let expected: [GF128; 10] = [
            GF128([0xd8, 0x38, 0xea, 0x96, 0xc2, 0x58, 0x48, 0x8a, 0x6b, 0xdb, 0xda, 0x8c, 0xdd, 0x94, 0xfb, 0xb4]),
            GF128([0x18, 0xfc, 0x9d, 0xd5, 0x0a, 0x26, 0xfb, 0x6f, 0x39, 0x7c, 0xd6, 0xe0, 0xf0, 0xaf, 0xeb, 0x7e]),
            GF128([0x60, 0xd1, 0x99, 0x32, 0x3d, 0x55, 0x76, 0xe8, 0xe4, 0x4c, 0x6c, 0x9e, 0xf7, 0x82, 0x47, 0xc7]),
            GF128([0xd0, 0xda, 0x30, 0x07, 0x9e, 0x18, 0xfa, 0x04, 0xab, 0x3b, 0xc8, 0x41, 0xe6, 0xef, 0x54, 0x6d]),
            GF128([0x07, 0xd2, 0x06, 0x06, 0xf5, 0xc3, 0x13, 0x83, 0x8a, 0x7c, 0x48, 0x8f, 0x44, 0xcd, 0xd7, 0xc9]),
            GF128([0xad, 0xd3, 0xb8, 0x8c, 0x33, 0xfc, 0xf0, 0xa8, 0xdf, 0x30, 0x67, 0xc0, 0x48, 0x6b, 0x87, 0x20]),
            GF128([0xf4, 0xfe, 0xff, 0x9a, 0x70, 0x9d, 0x37, 0x4b, 0x28, 0xf0, 0x42, 0x62, 0x09, 0x89, 0xa6, 0x8a]),
            GF128([0x49, 0x2c, 0x61, 0x2f, 0x8e, 0xf3, 0x73, 0x74, 0x2c, 0xfd, 0x2c, 0x75, 0xe1, 0xfc, 0x75, 0xe6]),
            GF128([0x94, 0x4e, 0xa2, 0x5e, 0xc5, 0x60, 0xc0, 0xcb, 0x1b, 0x07, 0x37, 0xf4, 0x39, 0xf2, 0xff, 0x17]),
            GF128([0x54, 0x38, 0x17, 0xd0, 0xd0, 0xcc, 0x4c, 0xec, 0x58, 0x0f, 0x4d, 0x0a, 0xac, 0x9a, 0x11, 0xd9]),
        ];

        for (x,(y,expected)) in xs.into_iter().zip_eq(ys.into_iter().zip_eq(expected)) {
            assert_eq!(x * y, expected);
        }
    }
}