use std::{borrow::Borrow, ops::{Add, AddAssign, Mul, Neg, Sub}};
use itertools::Itertools;
// use bytemuck::TransparentWrapper;
use ghash::{GHash, universal_hash::{KeyInit, UniversalHash}};
use rand::{Rng, CryptoRng};
use sha2::Digest;

use crate::{rep3_core::{network::NetSerializable, party::{DigestExt, RngExt}, share::HasZero}, share::{gf8::GF8, Field}};


#[derive(Copy, Clone, Debug, PartialEq, Eq)] //, TransparentWrapper)]
#[repr(transparent)]
pub struct GF128([u8; 16]);

impl GF128 {
    pub fn into_gf8(self) -> Vec<GF8> {
        self.0.into_iter().map(|b| GF8(b)).collect()
    }
}

impl Field for GF128 {
    const NBYTES: usize = 16;

    const ONE: Self = GF128([0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

    fn is_zero(&self) -> bool {
        return self.0.iter().all(|x| *x == 0);
    }
}

impl HasZero for GF128 {
    const ZERO: Self = GF128([0u8; 16]);
}

impl NetSerializable for GF128 {
    fn serialized_size(n_elements: usize) -> usize {
        n_elements * Self::NBYTES
    }

    fn as_byte_vec(it: impl IntoIterator<Item = impl Borrow<Self>>, len: usize) -> Vec<u8> {
        let mut vec = Vec::with_capacity(Self::serialized_size(len));
        it.into_iter().for_each(|gf| {
            let arr = gf.borrow().0;
            vec.extend_from_slice(&arr);
        });
        vec
    }

    fn as_byte_vec_slice(elements: &[Self]) -> Vec<u8> {
        let mut res = vec![0u8; Self::serialized_size(elements.len())];
        res.chunks_exact_mut(Self::NBYTES).zip_eq(elements).for_each(|(dst, gf)| {
            dst.copy_from_slice(&gf.0);
        });
        res
    }

    fn from_byte_slice(v: Vec<u8>, dest: &mut [Self]) {
        debug_assert_eq!(dest.len()*16, v.len());
        dest.iter_mut().zip(v.into_iter().chunks(16).into_iter()).for_each(|(dst, chunk)| {
            chunk.into_iter().enumerate().for_each(|(i,byte)| {
                dst.0[i] = byte;
            });
        });
    }

    fn from_byte_vec(v: Vec<u8>, _len: usize) -> Vec<Self> {
        debug_assert!(v.len()%16 == 0);
        v.into_iter().chunks(16).into_iter().map(|chunk| {
            let mut bytes = [0u8; 16];
            bytes.iter_mut().zip(chunk.into_iter()).for_each(|(dst,byte)| *dst = byte);
            Self(bytes)
        }).collect()
    }
}

impl Default for GF128 {
    fn default() -> Self {
        Self::ZERO
    }
}

impl Add for GF128 {
    type Output = GF128;
    
    fn add(mut self, rhs: Self) -> Self::Output {
        self += rhs;
        self
    }
}

impl AddAssign for GF128 {
    fn add_assign(&mut self, rhs: Self) {
        for i in 0..16 {
            self.0[i] ^= rhs.0[i];
        }
    }
}

impl Sub for GF128 {
    type Output = GF128;
    fn sub(self, rhs: Self) -> Self::Output {
        self + rhs
    }
}

impl Neg for GF128 {
    type Output = GF128;
    fn neg(self) -> Self::Output {
        self
    }
}

impl Mul for GF128 {
    type Output = GF128;
    fn mul(self, rhs: Self) -> Self::Output {
        // use GHASH to realize GF(2^128) multiplication
        // the first input block in GHASH is computed as Y = X * H
        // so we set self as key and rhs as input
        // and obtain Y from the output of the hash
        let mut hasher = GHash::new(&self.0.into());
        let block: ghash::Block = rhs.0.into();
        hasher.update(&[block]);
        let result = hasher.finalize();
        GF128(result.into())
    }
}

#[derive(Debug, PartialEq)]
pub struct TryFromGF128SliceError;

impl TryFrom<&[GF8]> for GF128 {
    type Error = TryFromGF128SliceError;
    fn try_from(value: &[GF8]) -> Result<Self, Self::Error> {
        if value.len() != 16 { return Err(TryFromGF128SliceError)}
        let mut bytes = [0u8; 16];
        for i in 0..16 {
            bytes[i] = value[i].0;
        }
        Ok(GF128(bytes))
    }
}

impl TryFrom<&[u8]> for GF128 {
    type Error = TryFromGF128SliceError;
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        if value.len() != 16 { return Err(TryFromGF128SliceError)}
        let mut bytes = [0u8; 16];
        bytes.copy_from_slice(value);
        Ok(GF128(bytes))
    }
}

// unsafe impl TransparentWrapper<[u8; 16]> for GF128 {}

impl RngExt for GF128 {
    fn fill<R: Rng + CryptoRng>(rng: &mut R, buf: &mut [Self]) {
        for gf in buf {
            rng.fill_bytes(&mut gf.0);
        }
    }

    fn generate<R: Rng + CryptoRng>(rng: &mut R, n: usize) -> Vec<Self> {
        let mut v = vec![Self::ZERO; n];
        Self::fill(rng, &mut v);
        v
    }
}

impl DigestExt for GF128 {
    fn update<D: Digest>(digest: &mut D, message: &[Self]) {
        for m in message {
            digest.update(m.0);
        }
    }
}

impl From<[GF8; 16]> for GF128 {
    fn from(value: [GF8; 16]) -> Self {
        let mut arr = [0u8; 16];
        arr.iter_mut().zip(value).for_each(|(dst, src)| *dst = src.0);
        Self(arr)
    }
}

impl From<[u8; 16]> for GF128 {
    fn from(value: [u8; 16]) -> Self {
        Self(value)
    }
}

// impl FieldVectorCommChannel<GF128> for CommChannel {
//     fn read_vector(&mut self, buffer: &mut [GF128]) -> std::io::Result<()> {
//         let mut buf = vec![0u8; 16*buffer.len()];
//         self.read(&mut buf)?;
//         for (dst, chunk) in buffer.iter_mut().zip(buf.into_iter().chunks(16).into_iter()) {
//             for (i,x) in chunk.enumerate() {
//                 dst.0[i] = x;
//             }
//         }
//         Ok(())
//     }

//     fn write_vector(&mut self, vector: &[GF128]) -> std::io::Result<()> {
//         let mut buf = vec![0u8; 16*vector.len()];
//         for (i,xi) in vector.iter().enumerate() {
//             buf[16*i..16*i+16].copy_from_slice(&xi.0);
//         }
//         self.write(&buf)
//     }
// }

#[cfg(test)]
mod test {
    use itertools::Itertools;
    use crate::{gcm::gf128::TryFromGF128SliceError, share::{gf8::GF8, Field}};

    use super::GF128;

    #[test]
    fn gf128_one() {
        let xs: [GF128; 10] = [
            GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]),
            GF128([0x87, 0xd0, 0x92, 0x6c, 0x5d, 0x31, 0x28, 0xa6, 0xd9, 0x9e, 0x43, 0xfd, 0x3a, 0xab, 0x93, 0xda]),
            GF128([0x39, 0x3a, 0x50, 0x5a, 0x96, 0xdc, 0x27, 0x89, 0x76, 0xe3, 0x55, 0x17, 0xa2, 0x01, 0x2e, 0x2b]),
            GF128([0xd2, 0xc0, 0x17, 0x30, 0x71, 0xbe, 0x56, 0xca, 0x5d, 0x99, 0xc8, 0x98, 0x46, 0xdc, 0xf2, 0x7f]),
            GF128([0x17, 0x44, 0x59, 0xad, 0xa0, 0x00, 0xb6, 0x96, 0xe3, 0x0c, 0x2d, 0x07, 0x0e, 0x5c, 0x32, 0x60]),
            GF128([0x9c, 0x49, 0x90, 0x8e, 0x87, 0x66, 0x59, 0xe4, 0x01, 0xa2, 0xfc, 0x47, 0x7f, 0x70, 0x46, 0x16]),
            GF128([0xb4, 0x1f, 0x43, 0xd4, 0x20, 0xf9, 0x6c, 0x83, 0x06, 0x99, 0x8a, 0x93, 0x75, 0x3c, 0xf3, 0x13]),
            GF128([0x05, 0x04, 0xa1, 0x8c, 0x6b, 0xfa, 0x72, 0x6c, 0x9d, 0xee, 0x33, 0x9c, 0x5f, 0xf8, 0xb2, 0x93]),
            GF128([0x18, 0xf5, 0x69, 0xb7, 0x6f, 0x55, 0x3c, 0x76, 0xee, 0x46, 0x89, 0xe4, 0x83, 0x7e, 0xf7, 0x88]),
            GF128([0x82, 0x19, 0x16, 0x6d, 0x93, 0x08, 0xd9, 0xb1, 0xf6, 0x8c, 0x4e, 0xd6, 0x85, 0x81, 0x6a, 0x1e]),
        ];
        // mul by GF128::ONE is the mult. identity
        for el in xs {
            assert_eq!(el, el * GF128::ONE);
        }
    }

    #[test]
    fn gf128_mul() {
        let xs: [GF128; 10] = [
            GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]),
            GF128([0x87, 0xd0, 0x92, 0x6c, 0x5d, 0x31, 0x28, 0xa6, 0xd9, 0x9e, 0x43, 0xfd, 0x3a, 0xab, 0x93, 0xda]),
            GF128([0x39, 0x3a, 0x50, 0x5a, 0x96, 0xdc, 0x27, 0x89, 0x76, 0xe3, 0x55, 0x17, 0xa2, 0x01, 0x2e, 0x2b]),
            GF128([0xd2, 0xc0, 0x17, 0x30, 0x71, 0xbe, 0x56, 0xca, 0x5d, 0x99, 0xc8, 0x98, 0x46, 0xdc, 0xf2, 0x7f]),
            GF128([0x17, 0x44, 0x59, 0xad, 0xa0, 0x00, 0xb6, 0x96, 0xe3, 0x0c, 0x2d, 0x07, 0x0e, 0x5c, 0x32, 0x60]),
            GF128([0x9c, 0x49, 0x90, 0x8e, 0x87, 0x66, 0x59, 0xe4, 0x01, 0xa2, 0xfc, 0x47, 0x7f, 0x70, 0x46, 0x16]),
            GF128([0xb4, 0x1f, 0x43, 0xd4, 0x20, 0xf9, 0x6c, 0x83, 0x06, 0x99, 0x8a, 0x93, 0x75, 0x3c, 0xf3, 0x13]),
            GF128([0x05, 0x04, 0xa1, 0x8c, 0x6b, 0xfa, 0x72, 0x6c, 0x9d, 0xee, 0x33, 0x9c, 0x5f, 0xf8, 0xb2, 0x93]),
            GF128([0x18, 0xf5, 0x69, 0xb7, 0x6f, 0x55, 0x3c, 0x76, 0xee, 0x46, 0x89, 0xe4, 0x83, 0x7e, 0xf7, 0x88]),
            GF128([0x82, 0x19, 0x16, 0x6d, 0x93, 0x08, 0xd9, 0xb1, 0xf6, 0x8c, 0x4e, 0xd6, 0x85, 0x81, 0x6a, 0x1e]),
        ];
        let ys: [GF128; 10] = [
            GF128([0xf6, 0xd3, 0x55, 0x67, 0x29, 0x91, 0x5d, 0x98, 0x58, 0xe6, 0xfc, 0xdb, 0xe4, 0xf4, 0x64, 0x68]),
            GF128([0x8d, 0xf9, 0x55, 0x21, 0x02, 0x30, 0xd2, 0x79, 0x3c, 0xa1, 0xcf, 0x42, 0x23, 0x3a, 0x60, 0x99]),
            GF128([0x8e, 0xb5, 0x80, 0x37, 0xc7, 0xdd, 0x4f, 0x20, 0x45, 0x4c, 0x7b, 0x2a, 0xc0, 0x5f, 0x12, 0x4e]),
            GF128([0x5a, 0x68, 0xef, 0xdb, 0x18, 0xc2, 0xd4, 0x54, 0x64, 0xa4, 0x96, 0x07, 0x5f, 0x76, 0x21, 0x6d]),
            GF128([0xac, 0xa1, 0xa4, 0x74, 0x80, 0x74, 0x14, 0x45, 0x40, 0x0f, 0x6f, 0x81, 0x6e, 0x02, 0xcf, 0xc8]),
            GF128([0x6a, 0x3f, 0x25, 0x82, 0x82, 0xf9, 0x56, 0xe6, 0x1f, 0xed, 0x6e, 0x7e, 0xe3, 0x8f, 0x6b, 0x90]),
            GF128([0x31, 0x10, 0x05, 0x31, 0x04, 0x98, 0x76, 0x45, 0xa7, 0x66, 0xc6, 0x17, 0x68, 0x16, 0x5f, 0x52]),
            GF128([0xd5, 0x04, 0x54, 0x58, 0xfe, 0xaa, 0xbe, 0x9d, 0x18, 0x2d, 0x9b, 0xfc, 0x3c, 0x07, 0x8d, 0xed]),
            GF128([0x96, 0x13, 0x1f, 0x1b, 0xab, 0x16, 0x60, 0xd3, 0xfb, 0xa6, 0x6a, 0xe3, 0x3c, 0xc9, 0x36, 0x12]),
            GF128([0xce, 0x8a, 0x6a, 0x4d, 0xb4, 0xa9, 0x6a, 0xcd, 0xd6, 0x06, 0xca, 0x93, 0x8c, 0xd7, 0x81, 0x23]),
        ];
        let expected: [GF128; 10] = [
            GF128([0xd8, 0x38, 0xea, 0x96, 0xc2, 0x58, 0x48, 0x8a, 0x6b, 0xdb, 0xda, 0x8c, 0xdd, 0x94, 0xfb, 0xb4]),
            GF128([0x18, 0xfc, 0x9d, 0xd5, 0x0a, 0x26, 0xfb, 0x6f, 0x39, 0x7c, 0xd6, 0xe0, 0xf0, 0xaf, 0xeb, 0x7e]),
            GF128([0x60, 0xd1, 0x99, 0x32, 0x3d, 0x55, 0x76, 0xe8, 0xe4, 0x4c, 0x6c, 0x9e, 0xf7, 0x82, 0x47, 0xc7]),
            GF128([0xd0, 0xda, 0x30, 0x07, 0x9e, 0x18, 0xfa, 0x04, 0xab, 0x3b, 0xc8, 0x41, 0xe6, 0xef, 0x54, 0x6d]),
            GF128([0x07, 0xd2, 0x06, 0x06, 0xf5, 0xc3, 0x13, 0x83, 0x8a, 0x7c, 0x48, 0x8f, 0x44, 0xcd, 0xd7, 0xc9]),
            GF128([0xad, 0xd3, 0xb8, 0x8c, 0x33, 0xfc, 0xf0, 0xa8, 0xdf, 0x30, 0x67, 0xc0, 0x48, 0x6b, 0x87, 0x20]),
            GF128([0xf4, 0xfe, 0xff, 0x9a, 0x70, 0x9d, 0x37, 0x4b, 0x28, 0xf0, 0x42, 0x62, 0x09, 0x89, 0xa6, 0x8a]),
            GF128([0x49, 0x2c, 0x61, 0x2f, 0x8e, 0xf3, 0x73, 0x74, 0x2c, 0xfd, 0x2c, 0x75, 0xe1, 0xfc, 0x75, 0xe6]),
            GF128([0x94, 0x4e, 0xa2, 0x5e, 0xc5, 0x60, 0xc0, 0xcb, 0x1b, 0x07, 0x37, 0xf4, 0x39, 0xf2, 0xff, 0x17]),
            GF128([0x54, 0x38, 0x17, 0xd0, 0xd0, 0xcc, 0x4c, 0xec, 0x58, 0x0f, 0x4d, 0x0a, 0xac, 0x9a, 0x11, 0xd9]),
        ];

        for (x,(y,expected)) in xs.into_iter().zip_eq(ys.into_iter().zip_eq(expected)) {
            assert_eq!(x * y, expected);
        }
    }

    #[test]
    fn from_gf8_array() {
        let expected = GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        let actual = GF128::from([GF8(0xa0), GF8(0x0d), GF8(0x26), GF8(0xf5), GF8(0x21), GF8(0x5c), GF8(0x8c), GF8(0x4c), GF8(0xf2), GF8(0x98), GF8(0xbc), GF8(0xcb), GF8(0x21), GF8(0x3f), GF8(0x2c), GF8(0x97)]);
        assert_eq!(expected, actual);
    }

    #[test]
    fn from_u8_array() {
        let expected = GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        let actual = GF128::from([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        assert_eq!(expected, actual);
    }

    #[test]
    fn try_from_gf8_slice() {
        let expected = GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        let slice = [GF8(0xa0), GF8(0x0d), GF8(0x26), GF8(0xf5), GF8(0x21), GF8(0x5c), GF8(0x8c), GF8(0x4c), GF8(0xf2), GF8(0x98), GF8(0xbc), GF8(0xcb), GF8(0x21), GF8(0x3f), GF8(0x2c), GF8(0x97)];
        let actual = GF128::try_from(slice.as_slice());
        assert_eq!(Ok(expected), actual);

        let slice_too_short = [GF8(0xa0), GF8(0x0d), GF8(0x26), GF8(0xf5), GF8(0x21), GF8(0x5c), GF8(0x8c), GF8(0x4c), GF8(0xf2), GF8(0x98), GF8(0xbc), GF8(0xcb), GF8(0x21), GF8(0x3f), GF8(0x2c)];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_too_short.as_slice()));

        let slice_empty: &[GF8] = &[];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_empty));

        let slice_too_long = [GF8(0xa0), GF8(0x0d), GF8(0x26), GF8(0xf5), GF8(0x21), GF8(0x5c), GF8(0x8c), GF8(0x4c), GF8(0xf2), GF8(0x98), GF8(0xbc), GF8(0xcb), GF8(0x21), GF8(0x3f), GF8(0x2c), GF8(0x97), GF8(0x56)];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_too_long.as_slice()));
    }

    #[test]
    fn try_from_u8_slice() {
        let expected = GF128([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        let actual = GF128::from([0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97]);
        assert_eq!(expected, actual);

        let slice_too_short = [0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_too_short.as_slice()));

        let slice_empty: &[u8] = &[];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_empty));

        let slice_too_long = [0xa0, 0x0d, 0x26, 0xf5, 0x21, 0x5c, 0x8c, 0x4c, 0xf2, 0x98, 0xbc, 0xcb, 0x21, 0x3f, 0x2c, 0x97, 0x33];
        assert_eq!(Err(TryFromGF128SliceError), GF128::try_from(slice_too_long.as_slice()));
    }
}